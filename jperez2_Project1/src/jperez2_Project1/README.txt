Jerry Perez, Student ID: 797294760

Section 1:
	All of my work was done in eclipse, which bypassed the need for any command line arguments. Instead, I was able to include the desired argument inside of Eclipse in order to create the buffer size and after that, the program would scan for input. After each input, I would press enter and be given the correct output.

Section 2:
	From the testcase, commands, and output file that was posted on Canvas, my program seems to match each of the commands and outputs that were given to us. 
	The only test case that my program seems to have trouble with is the second to last command -- a get command that is supposed to return: F01-Rec010, Tim Boe, 09 Deer Dr, age009. In my implementation it returns: F01-Rec010, Name010, address010, age010. It has been brought to my attention by Jackson and Andrew that it is intended to be that way due to the dirty flag with the set command. I am currently winding down on time walking through a debugger to understand why this is the case, especially since I set the dirty flag to true after each set.
	The only issue that I did have was getting the program to run through command line. It runs perfectly through Eclipse, but I tried running the file various ways through terminal to no avail. I'm not entirely sure if it is because I am operating off of Mac and the terminal execution is different than that of windows. However, I spent numerous hours attempting to execute through command line in all of the directories possible within this project structure and I kept getting a class not found error.

Section 3:
	The homework instructions made it clear that we assume that there is a student table that consists of 300 disk blocks each containing 100 records and each record with 40 bytes. However, it was not specific as to whether we ought to create this table so I implemented the functionality but commented it out just in case. 
	Aside from that, you will find several methods that I created in order to tailor the program to yield the outputs in the test cases. For one inside of the BufferPool class, I added a removeBlock() function that determines which block needs to be removed, and this function relies on another function called canWeRemove() which determines if there is a block that can be removed in the first place. Inside of the Frame class there is an initialize function that takes in a block number and sets the block ID of the frame at hand. There is also an eraseContent() function that takes all of the content that was once associated with a frame and empties it (this is done when a block is pinned and we determine if there is another block suitable for removal). There is also a remove() function inside of the Frame class that returns a boolean statement on whether or not the block is removable. If the block isn't pinned but it is dirty, then we proceed to write out to disk.
	Other than the mentioned functions, there are getters and setters for all variables. I followed the design structure of 3 main classes which are described in the homework pdf.